<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/sceneNode.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LS.Animation.html">LS.Animation</a></li>
            
                <li><a href="../classes/LS.Animation.Track.html">LS.Animation.Track</a></li>
            
                <li><a href="../classes/LS.Collision.html">LS.Collision</a></li>
            
                <li><a href="../classes/LS.Component.html">LS.Component</a></li>
            
                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
            
                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
            
                <li><a href="../classes/LS.Components.CameraController.html">LS.Components.CameraController</a></li>
            
                <li><a href="../classes/LS.Components.CameraFX.html">LS.Components.CameraFX</a></li>
            
                <li><a href="../classes/LS.Components.CustomData.html">LS.Components.CustomData</a></li>
            
                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
            
                <li><a href="../classes/LS.Components.FXGraphComponent.html">LS.Components.FXGraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
            
                <li><a href="../classes/LS.Components.GlobalFX.html">LS.Components.GlobalFX</a></li>
            
                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.Knob.html">LS.Components.Knob</a></li>
            
                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
            
                <li><a href="../classes/LS.Components.LightFX.html">LS.Components.LightFX</a></li>
            
                <li><a href="../classes/LS.Components.MeshRenderer.html">LS.Components.MeshRenderer</a></li>
            
                <li><a href="../classes/LS.Components.NodeManipulator.html">LS.Components.NodeManipulator</a></li>
            
                <li><a href="../classes/LS.Components.PlayAnimation.html">LS.Components.PlayAnimation</a></li>
            
                <li><a href="../classes/LS.Components.Poser.html">LS.Components.Poser</a></li>
            
                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
            
                <li><a href="../classes/LS.Components.Rotator.html">LS.Components.Rotator</a></li>
            
                <li><a href="../classes/LS.Components.Script.html">LS.Components.Script</a></li>
            
                <li><a href="../classes/LS.Components.Spherize.html">LS.Components.Spherize</a></li>
            
                <li><a href="../classes/LS.Components.Target.html">LS.Components.Target</a></li>
            
                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
            
                <li><a href="../classes/LS.Components.VRCameraController.html">LS.Components.VRCameraController</a></li>
            
                <li><a href="../classes/LS.CompositePattern.html">LS.CompositePattern</a></li>
            
                <li><a href="../classes/LS.Draw.html">LS.Draw</a></li>
            
                <li><a href="../classes/LS.Formats.html">LS.Formats</a></li>
            
                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
            
                <li><a href="../classes/LS.LScript.html">LS.LScript</a></li>
            
                <li><a href="../classes/LS.LSQ.html">LS.LSQ</a></li>
            
                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
            
                <li><a href="../classes/LS.Physics.html">LS.Physics</a></li>
            
                <li><a href="../classes/LS.PhysicsInstance.html">LS.PhysicsInstance</a></li>
            
                <li><a href="../classes/LS.Picking.html">LS.Picking</a></li>
            
                <li><a href="../classes/LS.Player.html">LS.Player</a></li>
            
                <li><a href="../classes/LS.Prefab.html">LS.Prefab</a></li>
            
                <li><a href="../classes/LS.Project.html">LS.Project</a></li>
            
                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
            
                <li><a href="../classes/LS.RenderInstance.html">LS.RenderInstance</a></li>
            
                <li><a href="../classes/LS.RenderSettings.html">LS.RenderSettings</a></li>
            
                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
            
                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
            
                <li><a href="../classes/LS.SceneTree.html">LS.SceneTree</a></li>
            
                <li><a href="../classes/LS.ShaderQuery.html">LS.ShaderQuery</a></li>
            
                <li><a href="../classes/LS.ShadersManager.html">LS.ShadersManager</a></li>
            
                <li><a href="../classes/LS.StandardMaterial.html">LS.StandardMaterial</a></li>
            
                <li><a href="../classes/LS.TextureFX.html">LS.TextureFX</a></li>
            
                <li><a href="../classes/LS.WBin.html">LS.WBin</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/sceneNode.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//****************************************************************************

/**
* The SceneNode class represents and object in the scene
* Is the base class for all objects in the scene as meshes, lights, cameras, and so
*
* @class SceneNode
* @param{String} id the id (otherwise a random one is computed)
* @constructor
*/

function SceneNode( name )
{
	//Generic
	this._name = name || (&quot;node_&quot; + (Math.random() * 10000).toFixed(0)); //generate random number
	this._uid = LS.generateUId(&quot;NODE-&quot;);
	this.layers = 3|0; //32 bits for layers (force to int)

	this._classList = {};
	//this.className = &quot;&quot;;
	//this.mesh = &quot;&quot;;

	//flags
	this.flags = {
		visible: true,
		selectable: true,
		two_sided: false,
		flip_normals: false,
		//seen_by_camera: true,
		//seen_by_reflections: true,
		cast_shadows: true,
		receive_shadows: true,
		ignore_lights: false, //not_affected_by_lights
		alpha_test: false,
		alpha_shadows: false,
		depth_test: true,
		depth_write: true
	};

	//Basic components
	this._components = []; //used for logic actions
	this.addComponent( new LS.Transform() );

	//material
	this._material = null;
	//this.material = new Material();
	this.extra = {}; //for extra info
}

//get methods from other classes
LS.extendClass( SceneNode, ComponentContainer ); //container methods
LS.extendClass( SceneNode, CompositePattern ); //container methods

/**
* changes the node name
* @method setName
* @param {String} new_name the new name
* @return {Object} returns true if the name changed
*/

Object.defineProperty( SceneNode.prototype, &#x27;name&#x27;, {
	set: function(name)
	{
		this.setName( name );
	},
	get: function(){
		return this._name;
	},
	enumerable: true
});

Object.defineProperty( SceneNode.prototype, &#x27;uid&#x27;, {
	set: function(uid)
	{
		if(!uid)
			return;

		if(uid[0] != LS._uid_prefix)
		{
			console.warn(&quot;Invalid UID, renaming it to: &quot; + uid );
			uid = LS._uid_prefix + uid;
		}

		if(uid == this._uid)
			return;
		if( this._in_tree &amp;&amp; this._in_tree._nodes_by_uid[ this.uid ] )
			delete this._in_tree._nodes_by_uid[ this.uid ];
		this._uid = uid;
		if( this._in_tree )
			this._in_tree._nodes_by_uid[ this.uid ] = this;
	},
	get: function(){
		return this._uid;
	},
	enumerable: true
});


Object.defineProperty( SceneNode.prototype, &#x27;visible&#x27;, {
	set: function(v)
	{
		this.flags.visible = v;
	},
	get: function(){
		return this.flags.visible;
	},
	enumerable: true
});

Object.defineProperty( SceneNode.prototype, &#x27;material&#x27;, {
	set: function(v)
	{
		this._material = v;
		if(!v)
			return;
		if(v.constructor === String)
			return;
		if(v._root &amp;&amp; v._root != this)
			console.warn( &quot;Cannot assign a material of one SceneNode to another, you must clone it or register it&quot; )
		else
			v._root = this; //link
	},
	get: function(){
		return this._material;
	},
	enumerable: true
});
	

SceneNode.prototype.setName = function(new_name)
{
	if(this._name == new_name) 
		return true; //no changes

	//check that the name is valid (doesnt have invalid characters)
	if(!LS.validateName(new_name))
		return false;

	var scene = this._in_tree;
	if(!scene)
	{
		this._name = new_name;
		return true;
	}

	//remove old link
	if( this._name )
		delete scene._nodes_by_name[ this._name ];

	//assign name
	this._name = new_name;

	//we already have another node with this name
	if( new_name &amp;&amp; !scene._nodes_by_name[ new_name ] )
		scene._nodes_by_name[ this._name ] = this;

	/**
	 * Node changed name
	 *
	 * @event name_changed
	 * @param {String} new_name
	 */
	LEvent.trigger( this, &quot;name_changed&quot;, new_name );
	if(scene)
		LEvent.trigger( scene, &quot;node_name_changed&quot;, this );
	return true;
}

Object.defineProperty( SceneNode.prototype, &#x27;classList&#x27;, {
	get: function() { return this._classList },
	set: function(v) {},
	enumerable: false
});

/**
* @property className {String}
*/
Object.defineProperty( SceneNode.prototype, &#x27;className&#x27;, {
	get: function() {
			var keys = null;
			if(Object.keys)
				keys = Object.keys(this._classList); 
			else
			{
				keys = [];
				for(var k in this._classList)
					keys.push(k);
			}
			return keys.join(&quot; &quot;);
		},
	set: function(v) { 
		this._classList = {};
		if(!v)
			return;
		var t = v.split(&quot; &quot;);
		for(var i in t)
			this._classList[ t[i] ] = true;
	},
	enumerable: true
});

SceneNode.prototype.getLocator = function()
{
	return this.uid;
}

SceneNode.prototype.getPropertyInfo = function( locator )
{
	var path = locator.split(&quot;/&quot;);
	return this.getPropertyInfoFromPath(path);
}

SceneNode.prototype.getPropertyInfoFromPath = function( path )
{
	var target = this;
	var varname = path[0];

	if(path.length == 0)
	{
		return {
			node: this,
			target: null,
			name: &quot;&quot;,
			value: this,
			type: &quot;node&quot;
		};
	}
    else if(path.length == 1) //compo or //var
	{
		if(path[0][0] == &quot;@&quot;)
		{
			target = this.getComponentByUId( path[0] );
			return {
				node: this,
				target: target,
				name: target ? LS.getObjectClassName( target ) : &quot;&quot;,
				type: &quot;component&quot;,
				value: target
			};
		}
		else if (path[0] == &quot;material&quot;)
		{
			target = this.getMaterial();
			return {
				node: this,
				target: target,
				name: target ? LS.getObjectClassName( target ) : &quot;&quot;,
				type: &quot;material&quot;,
				value: target
			};
		}

		var target = this.getComponent( path[0] );
		if(target)
		{
			return {
				node: this,
				target: target,
				name: target ? LS.getObjectClassName( target ) : &quot;&quot;,
				type: &quot;component&quot;,
				value: target
			};
		}

		switch(path[0])
		{
			case &quot;matrix&quot;:
			case &quot;x&quot;: 
			case &quot;y&quot;: 
			case &quot;z&quot;: 
				target = this.transform;
				varname = path[0];
				break;
			default: 
				target = this;
				varname = path[0];
			break;
		}
	}
    else if(path.length &gt; 1) //compo/var
	{
		if(path[0][0] == &quot;@&quot;)
		{
			varname = path[1];
			target = this.getComponentByUId( path[0] );
		}
		else if (path[0] == &quot;material&quot;)
		{
			target = this.getMaterial();
			varname = path[1];
		}
		else if (path[0] == &quot;flags&quot;)
		{
			target = this.flags;
			varname = path[1];
		}
		else
		{
			target = this.getComponent( path[0] );
			varname = path[1];
		}

		if(!target)
			return null;
	}
	else //ï¿½?
	{
	}

	var v = undefined;

	if( target.getPropertyInfoFromPath &amp;&amp; target != this )
	{
		var r = target.getPropertyInfoFromPath( path.slice(1) );
		if(r)
			return r;
	}

	if( target.getPropertyValue )
		v = target.getPropertyValue( varname );

	if(v === undefined &amp;&amp; target[ varname ] === undefined)
		return null;

	var value = v !== undefined ? v : target[ varname ];

	var extra_info = target.constructor[ &quot;@&quot; + varname ];
	var type = &quot;&quot;;
	if(extra_info)
		type = extra_info.type;
	if(!type &amp;&amp; value !== null &amp;&amp; value !== undefined)
	{
		if(value.constructor === String)
			type = &quot;string&quot;;
		else if(value.constructor === Boolean)
			type = &quot;boolean&quot;;
		else if(value.length)
			type = &quot;vec&quot; + value.length;
		else if(value.constructor === Number)
			type = &quot;number&quot;;
	}

	return {
		node: this,
		target: target,
		name: varname,
		value: value,
		type: type
	};
}

SceneNode.prototype.setPropertyValue = function( locator, value )
{
	var path = locator.split(&quot;/&quot;);
	return this.setPropertyValueFromPath(path, value);
}

SceneNode.prototype.setPropertyValueFromPath = function( path, value )
{
	var target = null;
	var varname = path[0];

	if(path.length &gt; 1)
	{
		if(path[0][0] == &quot;@&quot;)
		{
			varname = path[1];
			target = this.getComponentByUId( path[0] );
		}
		else if( path[1] == &quot;material&quot; )
		{
			target = this.getMaterial();
			varname = path[1];
		}
		else if( path[1] == &quot;flags&quot; )
		{
			target = this.flags;
			varname = path[1];
		}
		else 
		{
			target = this.getComponent( path[0] );
			varname = path[1];
		}

		if(!target)
			return null;
	}
	else { //special cases 
		switch ( path[0] )
		{
			case &quot;matrix&quot;: target = this.transform; break;
			case &quot;x&quot;:
			case &quot;translate.X&quot;: target = this.transform; varname = &quot;x&quot;; break;
			case &quot;y&quot;:
			case &quot;translate.Y&quot;: target = this.transform; varname = &quot;y&quot;; break;
			case &quot;z&quot;:
			case &quot;translate.Z&quot;: target = this.transform; varname = &quot;z&quot;; break;
			case &quot;rotateX.ANGLE&quot;: target = this.transform; varname = &quot;pitch&quot;; break;
			case &quot;rotateY.ANGLE&quot;: target = this.transform; varname = &quot;yaw&quot;; break;
			case &quot;rotateZ.ANGLE&quot;: target = this.transform; varname = &quot;roll&quot;; break;
			default: target = this; //null
		}
	}

	if(!target)
		return null;

	if(target.setPropertyValueFromPath &amp;&amp; target != this)
		if( target.setPropertyValueFromPath( path.slice(1), value ) === true )
			return target;
	
	if(target.setPropertyValue  &amp;&amp; target != this)
		if( target.setPropertyValue( varname, value ) === true )
			return target;

	if( target[ varname ] === undefined )
		return;

	//disabled because if the vars has a setter it wont be called using the array.set
	//if( target[ varname ] !== null &amp;&amp; target[ varname ].set )
	//	target[ varname ].set( value );
	//else
		target[ varname ] = value;

	return target;
}

SceneNode.prototype.getResources = function(res, include_children)
{
	//resources in components
	for(var i in this._components)
		if( this._components[i].getResources )
			this._components[i].getResources( res );

	//res in material
	if(this.material)
	{
		if(typeof(this.material) == &quot;string&quot;)
		{
			if(this.material[0] != &quot;:&quot;) //not a local material, then its a reference
			{
				res[this.material] = LS.Material;
			}
		}
		else //get the material to get the resources
		{
			var mat = this.getMaterial();
			if(mat)
				mat.getResources( res );
		}
	}

	//prefab
	if(this.prefab)
		res[ this.prefab ] = LS.Prefab;

	//propagate
	if(include_children)
		for(var i in this._children)
			this._children[i].getResources(res, true);

	return res;
}

SceneNode.prototype.getTransform = function() {
	return this.transform;
}

//Helpers

SceneNode.prototype.getMesh = function() {
	var mesh = this.mesh;
	if(!mesh &amp;&amp; this.meshrenderer)
		mesh = this.meshrenderer.mesh;
	if(!mesh) return null;
	if(mesh.constructor === String)
		return ResourcesManager.meshes[mesh];
	return mesh;
}

//Light component
SceneNode.prototype.getLight = function() {
	return this.light;
}

//Camera component
SceneNode.prototype.getCamera = function() {
	return this.camera;
}

SceneNode.prototype.getLODMesh = function() {
	var mesh = this.lod_mesh;
	if(!mesh &amp;&amp; this.meshrenderer)
		mesh = this.meshrenderer.lod_mesh;
	if(!mesh) return null;
	if(mesh.constructor === String)
		return ResourcesManager.meshes[mesh];
	return mesh;
}

SceneNode.prototype.setMesh = function(mesh_name, submesh_id)
{
	if(this.meshrenderer)
	{
		if(typeof(mesh_name) == &quot;string&quot;)
			this.meshrenderer.configure({ mesh: mesh_name, submesh_id: submesh_id });
		else
			this.meshrenderer.mesh = mesh_name;
	}
	else
		this.addComponent( new LS.MeshRenderer({ mesh: mesh_name, submesh_id: submesh_id }) );
}

SceneNode.prototype.loadAndSetMesh = function(mesh_filename, options)
{
	options = options || {};

	if( LS.ResourcesManager.meshes[mesh_filename] || !mesh_filename )
	{
		this.setMesh( mesh_filename );
		if(options.on_complete) options.on_complete( LS.ResourcesManager.meshes[mesh_filename] ,this);
		return;
	}

	var that = this;
	var loaded = LS.ResourcesManager.load(mesh_filename, options, function(mesh){
		that.setMesh(mesh.filename);
		that.loading -= 1;
		if(that.loading == 0)
		{
			LEvent.trigger(that,&quot;resource_loaded&quot;,that);
			delete that.loading;
		}
		if(options.on_complete)
			options.on_complete(mesh,that);
	});

	if(!loaded)
	{
		if(!this.loading)
		{
			this.loading = 1;

			LEvent.trigger(this,&quot;resource_loading&quot;);
		}
		else
			this.loading += 1;
	}
}

SceneNode.prototype.getMaterial = function()
{
	if (!this.material)
		return null;
	if(this.material.constructor === String)
	{
		if( !this._in_tree )
			return null;
		if( this.material[0] == &quot;@&quot; )//uid
			return LS.ResourcesManager.materials_by_uid[ this.material ];
		return LS.ResourcesManager.materials[ this.material ];
	}
	return this.material;
}


SceneNode.prototype.setPrefab = function(prefab_name)
{
	this._prefab_name = prefab_name;
	var prefab = LS.ResourcesManager.resources[ prefab_name ];
	if(!prefab)
		return;


}

/**
* Assigns this node to one layer
* @method setLayer
* @param {number} num layer number
* @param {boolean} value 
*/
SceneNode.prototype.setLayer = function(num, value)
{
	var f = 1&lt;&lt;num;
	this.layers = (this.layers &amp; (~f));
	if(value)
		this.layers |= f;
}

SceneNode.prototype.isInLayer = function(num)
{
	return (this.layers &amp; (1&lt;&lt;num)) !== 0;
}

SceneNode.prototype.getLayers = function()
{
	var r = [];
	if(!this.scene)
		return r;

	for(var i = 0; i &lt; 32; ++i)
	{
		if( this.layers &amp; (1&lt;&lt;i) )
			r.push( this.scene.layer_names[i] || (&quot;layer&quot;+i) );
	}
	return r;
}

/**
* remember clones this node and returns the new copy (you need to add it to the scene to see it)
* @method clone
* @return {Object} returns a cloned version of this node
*/

SceneNode.prototype.clone = function()
{
	var scene = this._in_tree;

	var new_name = scene ? scene.generateUniqueNodeName( this._name ) : this._name ;
	var newnode = new LS.SceneNode( new_name );
	var info = this.serialize();

	//remove all uids from nodes and components
	LS.clearUIds( info );

	info.uid = LS.generateUId(&quot;NODE-&quot;);
	newnode.configure( info );

	return newnode;
}

/**
* Configure this node from an object containing the info
* @method configure
* @param {Object} info the object with all the info (comes from the serialize method)
*/
SceneNode.prototype.configure = function(info)
{
	//identifiers parsing
	if (info.name)
		this.setName(info.name);
	else if (info.id)
		this.setName(info.id);
	if(info.layers !== undefined)
		this.layers = info.layers;

	if (info.uid)
	{
		this.uid = info.uid;
	}
	if (info.className &amp;&amp; info.className.constructor == String)	
		this.className = info.className;

	//TO DO: Change this to more generic stuff
	//some helpers (mostly for when loading from js object that come from importers
	if(info.mesh)
	{
		var mesh_id = info.mesh;

		var mesh = LS.ResourcesManager.meshes[ mesh_id ];
		var mesh_render_config = { mesh: mesh_id };

		if(info.submesh_id !== undefined)
			mesh_render_config.submesh_id = info.submesh_id;
		if(info.morph_targets !== undefined)
			mesh_render_config.morph_targets = info.morph_targets;

		var compo = new LS.Components.MeshRenderer(mesh_render_config);

		//parsed meshes have info about primitive
		if( mesh.primitive === &quot;line_strip&quot; )
		{
			compo.primitive = 3;
			delete mesh.primitive;
		}

		//add MeshRenderer
		this.addComponent( compo );

		//skinning
		if(mesh &amp;&amp; mesh.bones)
		{
			compo = new LS.Components.SkinDeformer();
			this.addComponent( compo );
		}

		//morph
		if( mesh &amp;&amp; mesh.morph_targets )
		{
			var compo = new LS.Components.MorphDeformer( { morph_targets: mesh.morph_targets } );
			this.addComponent( compo );
		}
	}

	//transform in matrix format could come from importers so we leave it
	if(info.model) 
		this.transform.fromMatrix( info.model ); 

	//first the no components
	if(info.material)
	{
		var mat_class = info.material.material_class;
		if(!mat_class) 
			mat_class = &quot;Material&quot;;
		this.material = typeof(info.material) == &quot;string&quot; ? info.material : new LS.MaterialClasses[mat_class](info.material);
	}

	if(info.flags) //merge
		for(var i in info.flags)
			this.flags[i] = info.flags[i];
	
	if(info.prefab) 
		this.prefab = info.prefab;

	//add animation tracks player
	if(info.animations)
	{
		this.animations = info.animations;
		this.addComponent( new LS.Components.PlayAnimation({animation:this.animations}) );
	}

	//extra user info
	if(info.extra)
		this.extra = info.extra;

	if(info.comments)
		this.comments = info.comments;

	//restore components
	if(info.components)
		this.configureComponents(info);

	//configure children too
	this.configureChildren(info);

	LEvent.trigger(this,&quot;configure&quot;,info);
}

/**
* Serializes this node by creating an object with all the info
* it contains info about the components too
* @method serialize
* @return {Object} returns the object with the info
*/
SceneNode.prototype.serialize = function()
{
	var o = {};

	if(this._name) 
		o.name = this._name;
	if(this.uid) 
		o.uid = this.uid;
	if(this.className) 
		o.className = this.className;
	o.layers = this.layers;

	//modules
	if(this.mesh &amp;&amp; typeof(this.mesh) == &quot;string&quot;) 
		o.mesh = this.mesh; //do not save procedural meshes
	if(this.submesh_id != null) 
		o.submesh_id = this.submesh_id;
	if(this.material) 
		o.material = typeof(this.material) == &quot;string&quot; ? this.material : this.material.serialize();
	if(this.prefab) 
		o.prefab = this.prefab;

	if(this.flags) 
		o.flags = LS.cloneObject(this.flags);

	//extra user info
	if(this.extra) 
		o.extra = this.extra;
	if(this.comments) 
		o.comments = this.comments;

	if(this._children)
		o.children = this.serializeChildren();

	//save components
	this.serializeComponents(o);

	//extra serializing info
	LEvent.trigger(this,&quot;serialize&quot;,o);

	return o;
}

//used to recompute matrix so when parenting one node it doesnt lose its global transformation
SceneNode.prototype._onChildAdded = function( child_node, recompute_transform )
{
	if(recompute_transform &amp;&amp; this.transform)
	{
		var M = child_node.transform.getGlobalMatrix(); //get son transform
		var M_parent = this.transform.getGlobalMatrix(); //parent transform
		mat4.invert(M_parent,M_parent);
		child_node.transform.fromMatrix( mat4.multiply(M_parent,M_parent,M) );
		child_node.transform.getGlobalMatrix(); //refresh
	}
	//link transform
	if(this.transform)
		child_node.transform._parent = this.transform;
}

SceneNode.prototype._onChangeParent = function( future_parent, recompute_transform )
{
	if(recompute_transform &amp;&amp; future_parent.transform)
	{
		var M = this.transform.getGlobalMatrix(); //get son transform
		var M_parent = future_parent.transform.getGlobalMatrix(); //parent transform
		mat4.invert(M_parent,M_parent);
		this.transform.fromMatrix( mat4.multiply(M_parent,M_parent,M) );
	}
	//link transform
	if(future_parent.transform)
		this.transform._parent = future_parent.transform;
}

SceneNode.prototype._onChildRemoved = function( node, recompute_transform, remove_components )
{
	if(this.transform)
	{
		//unlink transform
		if(recompute_transform)
		{
			var m = node.transform.getGlobalMatrix();
			node.transform._parent = null;
			node.transform.fromMatrix(m);
		}
		else
			node.transform._parent = null;
	}

	if( remove_components )
		node.removeAllComponents();
}

//Computes the bounding box from the render instance of this node
//doesnt take into account children
SceneNode.prototype.getBoundingBox = function( bbox, only_instances )
{
	bbox = bbox || BBox.create();
	var render_instances = this._instances;
	if(render_instances)
		for(var i = 0; i &lt; render_instances.length; ++i)
		{
			if(i == 0)
				bbox.set( render_instances[i].aabb );
			else
				BBox.merge( bbox, bbox, render_instances[i].aabb );
		}

	if(only_instances)
		return bbox;

	if( (!render_instances || render_instances.length == 0) &amp;&amp; this.transform )
		return BBox.fromPoint( this.transform.getGlobalPosition() );

	return bbox;
}

LS.SceneNode = SceneNode;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
