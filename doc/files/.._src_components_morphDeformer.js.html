<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/components/morphDeformer.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/LS.Animation.html">LS.Animation</a></li>
                                <li><a href="../classes/LS.Animation.Take.html">LS.Animation.Take</a></li>
                                <li><a href="../classes/LS.Animation.Track.html">LS.Animation.Track</a></li>
                                <li><a href="../classes/LS.BaseComponent.html">LS.BaseComponent</a></li>
                                <li><a href="../classes/LS.Collision.html">LS.Collision</a></li>
                                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
                                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
                                <li><a href="../classes/LS.Components.CameraController.html">LS.Components.CameraController</a></li>
                                <li><a href="../classes/LS.Components.CameraDirector.html">LS.Components.CameraDirector</a></li>
                                <li><a href="../classes/LS.Components.CameraFX.html">LS.Components.CameraFX</a></li>
                                <li><a href="../classes/LS.Components.Canvas3D.html">LS.Components.Canvas3D</a></li>
                                <li><a href="../classes/LS.Components.CustomData.html">LS.Components.CustomData</a></li>
                                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
                                <li><a href="../classes/LS.Components.FrameFX.html">LS.Components.FrameFX</a></li>
                                <li><a href="../classes/LS.Components.FXGraphComponent.html">LS.Components.FXGraphComponent</a></li>
                                <li><a href="../classes/LS.Components.FXStack.html">LS.Components.FXStack</a></li>
                                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
                                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
                                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
                                <li><a href="../classes/LS.Components.LightFX.html">LS.Components.LightFX</a></li>
                                <li><a href="../classes/LS.Components.LinesRenderer.html">LS.Components.LinesRenderer</a></li>
                                <li><a href="../classes/LS.Components.MeshRenderer.html">LS.Components.MeshRenderer</a></li>
                                <li><a href="../classes/LS.Components.MorphDeformer.html">LS.Components.MorphDeformer</a></li>
                                <li><a href="../classes/LS.Components.NodeManipulator.html">LS.Components.NodeManipulator</a></li>
                                <li><a href="../classes/LS.Components.ParticlesEmissor.html">LS.Components.ParticlesEmissor</a></li>
                                <li><a href="../classes/LS.Components.PlayAnimation.html">LS.Components.PlayAnimation</a></li>
                                <li><a href="../classes/LS.Components.Poser.html">LS.Components.Poser</a></li>
                                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
                                <li><a href="../classes/LS.Components.Rotator.html">LS.Components.Rotator</a></li>
                                <li><a href="../classes/LS.Components.SceneInclude.html">LS.Components.SceneInclude</a></li>
                                <li><a href="../classes/LS.Components.Script.html">LS.Components.Script</a></li>
                                <li><a href="../classes/LS.Components.SkinDeformer.html">LS.Components.SkinDeformer</a></li>
                                <li><a href="../classes/LS.Components.Skybox.html">LS.Components.Skybox</a></li>
                                <li><a href="../classes/LS.Components.Spline.html">LS.Components.Spline</a></li>
                                <li><a href="../classes/LS.Components.SVGRenderer.html">LS.Components.SVGRenderer</a></li>
                                <li><a href="../classes/LS.Components.Target.html">LS.Components.Target</a></li>
                                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
                                <li><a href="../classes/LS.Components.VRCameraController.html">LS.Components.VRCameraController</a></li>
                                <li><a href="../classes/LS.CompositePattern.html">LS.CompositePattern</a></li>
                                <li><a href="../classes/LS.DebugRender.html">LS.DebugRender</a></li>
                                <li><a href="../classes/LS.Draw.html">LS.Draw</a></li>
                                <li><a href="../classes/LS.Formats.html">LS.Formats</a></li>
                                <li><a href="../classes/LS.GLSLCode.html">LS.GLSLCode</a></li>
                                <li><a href="../classes/LS.GraphCode.html">LS.GraphCode</a></li>
                                <li><a href="../classes/LS.GUI.html">LS.GUI</a></li>
                                <li><a href="../classes/LS.Input.html">LS.Input</a></li>
                                <li><a href="../classes/LS.InteractiveController.html">LS.InteractiveController</a></li>
                                <li><a href="../classes/LS.Knob.html">LS.Knob</a></li>
                                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
                                <li><a href="../classes/LS.LScript.html">LS.LScript</a></li>
                                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
                                <li><a href="../classes/LS.oldStandardMaterial.html">LS.oldStandardMaterial</a></li>
                                <li><a href="../classes/LS.Pack.html">LS.Pack</a></li>
                                <li><a href="../classes/LS.Particle.html">LS.Particle</a></li>
                                <li><a href="../classes/LS.Physics.html">LS.Physics</a></li>
                                <li><a href="../classes/LS.PhysicsInstance.html">LS.PhysicsInstance</a></li>
                                <li><a href="../classes/LS.Picking.html">LS.Picking</a></li>
                                <li><a href="../classes/LS.Player.html">LS.Player</a></li>
                                <li><a href="../classes/LS.Prefab.html">LS.Prefab</a></li>
                                <li><a href="../classes/LS.Project.html">LS.Project</a></li>
                                <li><a href="../classes/LS.Ray.html">LS.Ray</a></li>
                                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
                                <li><a href="../classes/LS.RenderFrameContext.html">LS.RenderFrameContext</a></li>
                                <li><a href="../classes/LS.RenderInstance.html">LS.RenderInstance</a></li>
                                <li><a href="../classes/LS.RenderSettings.html">LS.RenderSettings</a></li>
                                <li><a href="../classes/LS.RenderState.html">LS.RenderState</a></li>
                                <li><a href="../classes/LS.Resource.html">LS.Resource</a></li>
                                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
                                <li><a href="../classes/LS.Scene.html">LS.Scene</a></li>
                                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
                                <li><a href="../classes/LS.ShaderBlock.html">LS.ShaderBlock</a></li>
                                <li><a href="../classes/LS.ShaderCode.html">LS.ShaderCode</a></li>
                                <li><a href="../classes/LS.ShaderMaterial.html">LS.ShaderMaterial</a></li>
                                <li><a href="../classes/LS.Shaders.html">LS.Shaders</a></li>
                                <li><a href="../classes/LS.SpatialContainer.html">LS.SpatialContainer</a></li>
                                <li><a href="../classes/LS.StandardMaterial.html">LS.StandardMaterial</a></li>
                                <li><a href="../classes/LS.Tween.html">LS.Tween</a></li>
                                <li><a href="../classes/LS.UnityMaterial.html">LS.UnityMaterial</a></li>
                                <li><a href="../classes/LS.WBin.html">LS.WBin</a></li>
                                <li><a href="../classes/LSQ.html">LSQ</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/LS.html">LS</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../src/components/morphDeformer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
///@INFO: UNCOMMON

/**
* It complements a MeshRenderer to add Morph Targets (Blend Shapes) to deform meshes.
* Morph Targets of a mesh must have the same topology and number of vertex, otherwise it won&#x27;t work.
* @class MorphDeformer
* @namespace LS.Components
* @constructor
* @param {Object} object to configure from
*/
function MorphDeformer(o)
{
	this.enabled = true;

	/**
	* The mode used to apply the morph targets, could be using the CPU, the GPU using uniforms( limited by the browser/driver) or using Textures (more expensive). Leave it as automatic so the system knows the best case.
	* @property mode {Number} MorphDeformer.AUTOMATIC, MorphDeformer.CPU, MorphDeformer.STREAMS, MorphDeformer.TEXTURES
	* @default MorphDeformer.AUTOMATIC;
	*/
	this.mode = MorphDeformer.AUTOMATIC;

	/**
	* An array with every morph targets info in the form of { mesh: mesh_name, weight: number }
	* @property morph_targets {Array}
	* @default [];
	*/
	this.morph_targets = [];

	if(global.gl)
	{
		if(MorphDeformer.max_supported_vertex_attribs === undefined)
			MorphDeformer.max_supported_vertex_attribs = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		if(MorphDeformer.max_supported_morph_targets_using_streams === undefined)
			MorphDeformer.max_supported_morph_targets_using_streams = (gl.getParameter( gl.MAX_VERTEX_ATTRIBS ) - 6) / 2; //6 reserved for vertex, normal, uvs, uvs2, weights, bones. 
	}

	if(o)
		this.configure(o);
}

MorphDeformer.AUTOMATIC = 0;
MorphDeformer.CPU = 1;
MorphDeformer.STREAMS = 2;
MorphDeformer.TEXTURES = 3;

MorphDeformer.icon = &quot;mini-icon-teapot.png&quot;;
MorphDeformer.force_GPU  = true; //used to avoid to recompile the shader when all morphs are 0
MorphDeformer[&quot;@mode&quot;] = { type:&quot;enum&quot;, values: {&quot;automatic&quot;: MorphDeformer.AUTOMATIC, &quot;CPU&quot;: MorphDeformer.CPU, &quot;streams&quot;: MorphDeformer.STREAMS, &quot;textures&quot;: MorphDeformer.TEXTURES }};

MorphDeformer.prototype.onAddedToNode = function(node)
{
	LEvent.bind( node, &quot;collectRenderInstances&quot;, this.onCollectInstances, this );
}

MorphDeformer.prototype.onRemovedFromNode = function(node)
{
	LEvent.unbind( node, &quot;collectRenderInstances&quot;, this.onCollectInstances, this );

	//disable
	if( this._last_RI )
		this.disableMorphingGPU( this._last_RI );
	this._last_RI = null;
}

MorphDeformer.prototype.getResources = function(res)
{
	for(var i = 0; i &lt; this.morph_targets.length; ++i)
		if( this.morph_targets[i].mesh )
			res[ this.morph_targets[i].mesh ] = GL.Mesh;
}

MorphDeformer.prototype.onResourceRenamed = function (old_name, new_name, resource)
{
	for(var i = 0; i &lt; this.morph_targets.length; ++i)
		if( this.morph_targets[i].mesh == old_name )
			this.morph_targets[i].mesh = new_name;
}


/**
* Sets the weight for all the 
* @method clearWeights
* @param {Object} object with the serialized info
*/
MorphDeformer.prototype.clearWeights = function()
{
	for(var i = 0; i &lt; this.morph_targets.length; ++i)
		this.morph_targets[i].weight = 0;
}

MorphDeformer.prototype.onCollectInstances = function( e, render_instances )
{
	if(!render_instances.length || MorphDeformer.max_supported_vertex_attribs &lt; 16)
		return;

	var morph_RI = this.enabled ? render_instances[ render_instances.length - 1] : null;
	
	if( morph_RI != this._last_RI &amp;&amp; this._last_RI )
		this.disableMorphingGPU( this._last_RI );
	this._last_RI = morph_RI;

	if( !morph_RI || !morph_RI.mesh)
		return;

	this._last_base_mesh = morph_RI.mesh;
	this._valid_morphs = this.computeValidMorphs( this._valid_morphs, morph_RI.mesh );

	//grab the RI created previously and modified
	//this.applyMorphTargets( last_RI );

	if(this.mode === MorphDeformer.AUTOMATIC )
	{
		if( this._morph_texture_supported === undefined )
			this._morph_texture_supported = (gl.extensions[&quot;OES_texture_float&quot;] !== undefined &amp;&amp; gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) &gt; 1);

		if( this._valid_morphs.length == 0 &amp;&amp; !MorphDeformer.force_GPU )
			return;

		if( this._valid_morphs.length &lt;= MorphDeformer.max_supported_morph_targets_using_streams ) //use GPU
			this.applyMorphTargetsByGPU( morph_RI, this._valid_morphs );
		else if( this._morph_texture_supported ) //use GPU with textures
			this.applyMorphUsingTextures( morph_RI, this._valid_morphs );
		else
			this.applyMorphBySoftware( morph_RI, this._valid_morphs );
	}
	else
	{
		switch( this.mode )
		{
			case MorphDeformer.STREAMS: this.applyMorphTargetsByGPU( morph_RI, this._valid_morphs ); break;
			case MorphDeformer.TEXTURES: this.applyMorphUsingTextures( morph_RI, this._valid_morphs ); break;
			default: this.applyMorphBySoftware( morph_RI, this._valid_morphs ); break;
		}
	}
}

//returns a list of the morph targets that have some weight and with a mesh that is loaded
MorphDeformer.prototype.computeValidMorphs = function( valid_morphs, base_mesh )
{
	valid_morphs = valid_morphs || [];
	valid_morphs.length = 0;

	if(!base_mesh)
		return valid_morphs;

	//sort by weight
	var morph_targets = this.morph_targets.concat();
	morph_targets.sort( function(a,b) { return Math.abs(b.weight) - Math.abs(a.weight);  } );

	//collect
	for(var i = 0; i &lt; morph_targets.length; ++i)
	{
		var morph = morph_targets[i];
		if(!morph.mesh || Math.abs(morph.weight) &lt; 0.001)
			continue;
		var morph_mesh = LS.ResourcesManager.resources[ morph.mesh ];
		if(!morph_mesh || morph_mesh.constructor !== GL.Mesh)
			continue;
		if(!morph_mesh.info)
			morph_mesh.info = {};
		morph_mesh.info.morph_target_from = base_mesh.filename;
		valid_morphs.push( { name: morph.mesh, weight: morph.weight, mesh: morph_mesh } );
	}

	return valid_morphs;
}

//add to the RI the info to apply the morphs using streams in the GPU
MorphDeformer.prototype.applyMorphTargetsByGPU = function( RI, valid_morphs )
{
	var base_mesh = RI.mesh;

	var base_vertices_buffer = base_mesh.vertexBuffers[&quot;vertices&quot;];
	var streams_code = &quot;&quot;;
	var morphs_buffers = {};
	var morphs_weights = [];

	//collect (max 4 if using streams)
	for(var i = 0; i &lt; valid_morphs.length &amp;&amp; i &lt; 4; ++i)
	{
		var morph = valid_morphs[i];
		var morph_mesh = morph.mesh;

		var vertices_buffer = morph_mesh.vertexBuffers[&quot;vertices&quot;];
		if(!vertices_buffer || vertices_buffer.data.length != base_vertices_buffer.data.length)
			continue;

		var normals_buffer = morph_mesh.vertexBuffers[&quot;normals&quot;];
		if(!normals_buffer)
			continue;

		var vertices_cloned = vertices_buffer.clone(true);
		var normals_cloned = normals_buffer.clone(true);
		vertices_cloned.attribute = null;
		normals_cloned.attribute = null;

		morphs_buffers[&quot;a_vertex_morph&quot; + i ] = vertices_cloned;
		morphs_buffers[&quot;a_normal_morph&quot; + i ] = normals_cloned;

		morphs_weights.push( morph.weight );
	}

	//add buffers
	RI.vertex_buffers = {};
	for(var i in base_mesh.vertexBuffers)
		RI.vertex_buffers[i] = base_mesh.vertexBuffers[i];
	for(var i in morphs_buffers)
		RI.vertex_buffers[i] = morphs_buffers[i];

	if(RI.samplers[ LS.Renderer.MORPHS_TEXTURE_SLOT ])
	{
		delete RI.uniforms[&quot;u_morph_vertices_texture&quot;];
		delete RI.uniforms[&quot;u_morph_normals_texture&quot;];
		RI.samplers[ LS.Renderer.MORPHS_TEXTURE_SLOT ] = null;
		RI.samplers[ LS.Renderer.MORPHS_TEXTURE2_SLOT ] = null;
	}

	var weights = this._stream_weights;
	if(!weights)
		weights = this._stream_weights = new Float32Array( 4 );
	else if( !weights.fill ) //is an Array?
	{
		for(var i = 0; i &lt; weights.length; ++i)
			weights[i] = 0;
	}
	else
		weights.fill(0); //fill first because morphs_weights could have zero length
	weights.set( morphs_weights );
	RI.uniforms[&quot;u_morph_weights&quot;] = weights;

	//SHADER BLOCK
	RI.addShaderBlock( MorphDeformer.shader_block ); //global
	RI.addShaderBlock( LS.MorphDeformer.morphing_streams_block, { u_morph_weights: weights } );
	RI.removeShaderBlock( LS.MorphDeformer.morphing_texture_block );
}

MorphDeformer.prototype.applyMorphUsingTextures = function( RI, valid_morphs )
{
	var base_mesh = RI.mesh;
	var base_vertices_buffer = base_mesh.vertexBuffers[&quot;vertices&quot;];
	var base_normals_buffer = base_mesh.vertexBuffers[&quot;normals&quot;];

	//create textures for the base mesh
	if(!base_vertices_buffer._texture)
		base_vertices_buffer._texture = this.createGeometryTexture( base_vertices_buffer );
	if(!base_normals_buffer._texture)
		base_normals_buffer._texture = this.createGeometryTexture( base_normals_buffer );

	//LS.RM.textures[&quot;:debug_base_vertex&quot;] = base_vertices_buffer._texture;
	//LS.RM.textures[&quot;:debug_base_normal&quot;] = base_normals_buffer._texture;


	var morphs_textures = [];

	//create the texture container where all will be merged
	if(!this._morphtarget_vertices_texture || this._morphtarget_vertices_texture.height != base_vertices_buffer._texture.height )
	{
		this._morphtarget_vertices_texture = new GL.Texture( base_vertices_buffer._texture.width, base_vertices_buffer._texture.height, { format: gl.RGB, type: gl.FLOAT, filter: gl.NEAREST, wrap: gl.CLAMP_TO_EDGE, no_flip: true });
		this._morphtarget_normals_texture = new GL.Texture( base_normals_buffer._texture.width, base_normals_buffer._texture.height, { format: gl.RGB, type: gl.FLOAT, filter: gl.NEAREST, wrap: gl.CLAMP_TO_EDGE, no_flip: true });

		//used in the shader
		this._texture_size = vec4.fromValues( this._morphtarget_vertices_texture.width, this._morphtarget_vertices_texture.height, 
			1 / this._morphtarget_vertices_texture.width, 1 / this._morphtarget_vertices_texture.height );

		//LS.RM.textures[&quot;:debug_morph_vertex&quot;] = this._morphtarget_vertices_texture;
		//LS.RM.textures[&quot;:debug_morph_normal&quot;] = this._morphtarget_normals_texture;
	}

	//prepare morph targets
	for(var i = 0; i &lt; valid_morphs.length; ++i)
	{
		var morph = valid_morphs[i];
		var morph_mesh = morph.mesh;

		var vertices_buffer = morph_mesh.vertexBuffers[&quot;vertices&quot;];
		if(!vertices_buffer || vertices_buffer.data.length != base_vertices_buffer.data.length)
			continue;

		var normals_buffer = morph_mesh.vertexBuffers[&quot;normals&quot;];
		if(!normals_buffer)
			continue;

		//create texture
		if(!vertices_buffer._texture)
			vertices_buffer._texture = this.createGeometryTexture( vertices_buffer );
		if(!normals_buffer._texture)
			normals_buffer._texture = this.createGeometryTexture( normals_buffer );

		//LS.RM.textures[&quot;:debug_morph_vertex_&quot; + i] = vertices_buffer._texture;
		//LS.RM.textures[&quot;:debug_morph_normal_&quot; + i] = normals_buffer._texture;

		morphs_textures.push( { weight: morph.weight, vertices: vertices_buffer._texture, normals: normals_buffer._texture } );
	}

	//blend all morphs targets in one texture

	var shader = this.getMorphTextureShader();
	shader.uniforms({ u_base_texture: 0, u_morph_texture: 1 });

	gl.disable( gl.DEPTH_TEST );
	gl.enable( gl.BLEND );
	gl.blendFunc( gl.ONE, gl.ONE );

	base_vertices_buffer._texture.bind(0);
	var quad_mesh = GL.Mesh.getScreenQuad();

	this._morphtarget_vertices_texture.drawTo( function(){
		gl.clearColor( 0,0,0,0 );
		gl.clear( gl.COLOR_BUFFER_BIT );
		for(var i = 0; i &lt; morphs_textures.length; ++i )
		{
			var stream_texture = morphs_textures[i].vertices;
			stream_texture.bind(1);
			shader.uniforms({ u_weight: morphs_textures[i].weight });
			shader.draw( quad_mesh, gl.TRIANGLES );
		}
	});

	base_normals_buffer._texture.bind(0);

	this._morphtarget_normals_texture.drawTo( function(){
		gl.clearColor( 0,0,0,0 );
		gl.clear( gl.COLOR_BUFFER_BIT );
		for(var i = 0; i &lt; morphs_textures.length; ++i )
		{
			var stream_texture = morphs_textures[i].normals;
			stream_texture.bind(1);
			shader.uniforms({ u_weight: morphs_textures[i].weight });
			shader.draw( quad_mesh, gl.TRIANGLES );
		}
	});

	gl.disable( gl.BLEND );

	//create sequence numbers buffer of the same size
	var num_verts = base_vertices_buffer.data.length / 3;
	if(!this._ids_buffer || this._ids_buffer.data.length != num_verts )
	{
		var ids_data = new Float32Array( num_verts );
		for(var i = 0; i &lt; num_verts; ++i)
			ids_data[i] = i;
		this._ids_buffer = new GL.Buffer( gl.ARRAY_BUFFER, ids_data, 1, gl.STATIC_DRAW );
		this._ids_buffer.attribute = &quot;a_morphing_ids&quot;;
	}

	//modify the RI to have the displacement texture
	RI.uniforms[&quot;u_morph_vertices_texture&quot;] = LS.Renderer.MORPHS_TEXTURE_SLOT;
	RI.samplers[ LS.Renderer.MORPHS_TEXTURE_SLOT ] = this._morphtarget_vertices_texture;

	RI.uniforms[&quot;u_morph_normals_texture&quot;] = LS.Renderer.MORPHS_TEXTURE2_SLOT;
	RI.samplers[ LS.Renderer.MORPHS_TEXTURE2_SLOT ] = this._morphtarget_normals_texture;

	RI.uniforms[&quot;u_morph_texture_size&quot;] = this._texture_size;

	//add the ids (the texture with 0,1,2, 3,4,5, ...)
	RI.vertex_buffers[&quot;a_morphing_ids&quot;] = this._ids_buffer;

	//SHADER BLOCK
	RI.addShaderBlock( MorphDeformer.shader_block );
	RI.addShaderBlock( LS.MorphDeformer.morphing_texture_block, { 
				u_morph_vertices_texture: LS.Renderer.MORPHS_TEXTURE_SLOT, 
				u_morph_normals_texture: LS.Renderer.MORPHS_TEXTURE2_SLOT, 
				u_morph_texture_size: this._texture_size 
			});
	RI.removeShaderBlock( LS.MorphDeformer.morphing_streams_block );
}


MorphDeformer.prototype.disableMorphingGPU = function( RI )
{
	if( !RI )
		return;
	
	if( RI.samplers[ LS.Renderer.MORPHS_TEXTURE_SLOT ] )
	{
		RI.samplers[ LS.Renderer.MORPHS_TEXTURE_SLOT ] = null;
		RI.samplers[ LS.Renderer.MORPHS_TEXTURE2_SLOT ] = null;
		delete RI.uniforms[&quot;u_morph_vertices_texture&quot;];
		delete RI.uniforms[&quot;u_morph_normals_texture&quot;];
	}

	RI.removeShaderBlock( LS.MorphDeformer.shader_block );
	RI.removeShaderBlock( LS.MorphDeformer.morphing_streams_block );
	RI.removeShaderBlock( LS.MorphDeformer.morphing_texture_block );
}

MorphDeformer.prototype.applyMorphBySoftware = function( RI, valid_morphs )
{
	var base_mesh = RI.mesh;
	var base_vertices_buffer = base_mesh.vertexBuffers[&quot;vertices&quot;];

	this.disableMorphingGPU( RI ); //disable GPU version

	var key = &quot;&quot;; //used to avoid computing the mesh every frame

	//collect
	for(var i = 0; i &lt; valid_morphs.length; ++i)
	{
		var morph = valid_morphs[i];
		key += morph.name + &quot;|&quot; + morph.weight.toFixed(2) + &quot;|&quot;;
	}

	//to avoid recomputing if nothing has changed
	if(key == this._last_key)
	{
		//change the RI
		if(this._final_vertices_buffer)
			RI.vertex_buffers[&quot;vertices&quot;] = this._final_vertices_buffer;
		if(this._final_normals_buffer)
			RI.vertex_buffers[&quot;normals&quot;] = this._final_normals_buffer;
		return; 
	}
	this._last_key = key;

	var base_vertices_buffer = base_mesh.vertexBuffers[&quot;vertices&quot;];
	var base_vertices = base_vertices_buffer.data;
	var base_normals_buffer = base_mesh.vertexBuffers[&quot;normals&quot;];
	var base_normals = base_normals_buffer.data;

	//create final buffers
	if(!this._final_vertices || this._final_vertices.length != base_vertices.length )
	{
		this._final_vertices = new Float32Array( base_vertices.length );
		this._final_vertices_buffer = new GL.Buffer( gl.ARRAY_BUFFER, this._final_vertices, 3, gl.STREAM_DRAW );
		this._final_vertices_buffer.attribute = &quot;a_vertex&quot;;
	}

	if(!this._final_normals || this._final_normals.length != base_normals.length )
	{
		this._final_normals = new Float32Array( base_normals.length );
		this._final_normals_buffer = new GL.Buffer( gl.ARRAY_BUFFER, this._final_normals, 3, gl.STREAM_DRAW );
		this._final_normals_buffer.attribute = &quot;a_normal&quot;;
	}

	var vertices = this._final_vertices;
	var normals = this._final_normals;

	vertices.set( base_vertices );
	normals.set( base_normals );

	var morphs_vertices = [];
	var morphs_normals = [];
	var morphs_weights = [];
	var num_morphs = valid_morphs.length;

	for(var i = 0; i &lt; valid_morphs.length; ++i)
	{
		var morph = valid_morphs[i];
		morphs_vertices.push( morph.mesh.vertexBuffers[&quot;vertices&quot;].data );
		morphs_normals.push( morph.mesh.vertexBuffers[&quot;normals&quot;].data );
		morphs_weights.push( morph.weight );
	}

	//fill them 
	for(var i = 0, l = vertices.length; i &lt; l; i += 3)
	{
		var v = vertices.subarray(i,i+3);
		var n = normals.subarray(i,i+3);

		for(var j = 0; j &lt; num_morphs; ++j)
		{
			var m_v = morphs_vertices[j];
			var m_n = morphs_normals[j];
			var w = morphs_weights[j];
			v[0] += (m_v[i] - base_vertices[i]) * w;
			v[1] += (m_v[i+1] - base_vertices[i+1]) * w;
			v[2] += (m_v[i+2] - base_vertices[i+2]) * w;
			n[0] += (m_n[i] - base_normals[i]) * w;
			n[1] += (m_n[i+1] - base_normals[i+1]) * w;
			n[2] += (m_n[i+2] - base_normals[i+2]) * w;
		}
	}

	this._final_vertices_buffer.upload(  gl.STREAM_DRAW );
	this._final_normals_buffer.upload(  gl.STREAM_DRAW );

	//change the RI
	RI.vertex_buffers[&quot;vertices&quot;] = this._final_vertices_buffer;
	RI.vertex_buffers[&quot;normals&quot;] = this._final_normals_buffer;

}




MorphDeformer._blend_shader_fragment_code = &quot;\n\
	precision highp float;\n\
	uniform sampler2D u_base_texture;\n\
	uniform sampler2D u_morph_texture;\n\
	uniform float u_weight;\n\
	varying vec2 v_coord;\n\
	void main() {\n\
		gl_FragColor = u_weight * ( texture2D(u_morph_texture, v_coord) - texture2D(u_base_texture, v_coord) );\n\
		gl_FragColor.w = 1.0;\n\
	}\n\
&quot;;

MorphDeformer.prototype.getMorphTextureShader  = function()
{
	if(!this._blend_shader)
		this._blend_shader = new GL.Shader( Shader.SCREEN_VERTEX_SHADER, MorphDeformer._blend_shader_fragment_code );
	return this._blend_shader;
}

MorphDeformer.prototype.createGeometryTexture = function( data_buffer )
{
	var stream_data = data_buffer.data;
	var buffer = stream_data.buffer;

	var max_texture_size = gl.getParameter( gl.MAX_TEXTURE_SIZE );

	var num_floats = stream_data.length; 
	var num_vertex = num_floats / 3;
	var width = Math.min( max_texture_size, num_vertex );
	var height = Math.ceil( num_vertex / width );

	var buffer_padded = new Float32Array( width * height * 3 );
	buffer_padded.set( stream_data );
	
	var texture = new GL.Texture( width, height, { format: gl.RGB, type: gl.FLOAT, filter: gl.NEAREST, wrap: gl.CLAMP_TO_EDGE, pixel_data: buffer_padded, no_flip: true });
	return texture;
}

/**
* returns the index of the morph target that uses this mesh
* @method getMorphIndex
* @param {String} mesh_name the name (filename) of the mesh in the morph target
* @return {number} the index
*/
MorphDeformer.prototype.getMorphIndex = function(mesh_name)
{
	for(var i = 0; i &lt; this.morph_targets.length; ++i)
		if (this.morph_targets[i].mesh == mesh_name )
			return i;
	return -1;
}

/**
* sets the mesh for a morph target
* @method setMorphMesh
* @param {number} index the index of the morph target
* @param {String} mesh the mesh resource
*/
MorphDeformer.prototype.setMorphMesh = function(index, value)
{
	if(index &gt;= this.morph_targets.length)
		return;
	this.morph_targets[index].mesh = value;
}

/**
* sets the weight for a morph target
* @method setMorphWeight
* @param {number} index the index of the morph target
* @param {number} weight the weight
*/
MorphDeformer.prototype.setMorphWeight = function(index, value)
{
	if(index &gt;= this.morph_targets.length)
		return;
	this.morph_targets[index].weight = value;
}

MorphDeformer.prototype.getPropertyInfoFromPath = function( path )
{
	if(path[0] != &quot;morphs&quot;)
		return;

	if(path.length == 1)
		return {
			node: this._root,
			target: this.morph_targets,
			type: &quot;object&quot;
		};

	var num = parseInt( path[1] );
	if(num &gt;= this.morph_targets.length)
		return;

	var varname = path[2];
	if(varname != &quot;mesh&quot; &amp;&amp; varname != &quot;weight&quot;)
		return;

	return {
		node: this._root,
		target: this.morph_targets[num],
		name: varname,
		value: this.morph_targets[num][ varname ] !== undefined ? this.morph_targets[num][ varname ] : null,
		type: varname == &quot;mesh&quot; ? &quot;mesh&quot; : &quot;number&quot;
	};
}

MorphDeformer.prototype.setPropertyValueFromPath = function( path, value, offset )
{
	offset = offset || 0;

	if( path.length &lt; (offset+1) )
		return;

	if( path[offset] != &quot;morphs&quot; )
		return;

	var num = parseInt( path[offset+1] );
	if(num &gt;= this.morph_targets.length)
		return;

	var varname = path[offset+2];
	this.morph_targets[num][ varname ] = value;
}

//used for graphs
MorphDeformer.prototype.setProperty = function(name, value)
{
	if( name == &quot;enabled&quot; )
		this.enabled = value;
	else if( name.substr(0,5) == &quot;morph&quot; )
	{
		name = name.substr(5);
		var t = name.split(&quot;_&quot;);
		var num = parseInt( t[0] );
		if( num &lt; this.morph_targets.length )
		{
			if( t[1] == &quot;weight&quot; )
				this.morph_targets[ num ].weight = value;
			else if( t[1] == &quot;mesh&quot; )
				this.morph_targets[ num ].mesh = value;
		}
	}
}


MorphDeformer.prototype.getPropertiesInfo = function()
{
	var properties = {
		enabled: &quot;boolean&quot;
	};

	for(var i = 0; i &lt; this.morph_targets.length; i++)
	{
		properties[ &quot;morph&quot; + i + &quot;_weight&quot; ] = &quot;number&quot;;
		properties[ &quot;morph&quot; + i + &quot;_mesh&quot; ] = &quot;Mesh&quot;;
	}

	return properties;
}

/**
* Returns the base mesh on which the morph targets will be applied
* @method getBaseMesh
*/
MorphDeformer.prototype.getBaseMesh = function()
{
	if(!this._root)
		return null;
	if( this._last_base_mesh )
		return this._last_base_mesh;
	var mesh_renderer = this._root.getComponent( LS.Components.MeshRenderer );
	if( mesh_renderer )
		return LS.ResourcesManager.resources[ mesh_renderer.mesh ];
	return null;
}

/**
* Removes innecesary morph targets and removes data from mesh that is already in the base mesh
* @method optimizeMorphTargets
*/
MorphDeformer.prototype.optimizeMorphTargets = function()
{
	//base mesh
	var base_mesh = this.getBaseMesh();

	var morph_targets = this.morph_targets.concat();

	for(var i = 0; i &lt; morph_targets.length; ++i)
	{
		var morph = morph_targets[i];
		var mesh = LS.ResourcesManager.meshes[ morph.mesh ];
		if(!mesh)
			continue;
		
		//remove data not used 
		mesh.removeVertexBuffer(&quot;coords&quot;, true);
		mesh.removeIndexBuffer(&quot;triangles&quot;, true);
		mesh.removeIndexBuffer(&quot;wireframe&quot;, true);

		//compute difference
		if( base_mesh )
		{
			var diff = MorphDeformer.computeMeshDifference( base_mesh, mesh );
			if( diff &lt; 0.1 ) //too similar
			{
				var mesh_fullpath = mesh.fullpath || mesh.filename;
				console.log(&quot;morph target is too similar to base mesh, removing it: &quot; + mesh_fullpath );
				var index = this.morph_targets.indexOf( morph );
				this.morph_targets.splice( index,1 );
				LS.ResourcesManager.unregisterResource( mesh_fullpath );
				var container_fullpath = mesh.from_pack || mesh.from_prefab;
				if( container_fullpath )
				{
					var container = LS.ResourcesManager.resources[ container_fullpath ];
					if(container)
						container.removeResource( mesh_fullpath );
				}
				continue;
			}
		}

		LS.ResourcesManager.resourceModified( mesh );
	}

	console.log(&quot;Morph targets optimized&quot;);
}

//computes the difference between to meshes, used to detect useless morph targets
MorphDeformer.computeMeshDifference = function( mesh_a, mesh_b )
{
	if(!mesh_a || !mesh_b || !mesh_a.vertexBuffers[&quot;vertices&quot;] || !mesh_b.vertexBuffers[&quot;vertices&quot;])
		return 0;

	var vertices_a = mesh_a.vertexBuffers[&quot;vertices&quot;].data;
	var vertices_b = mesh_b.vertexBuffers[&quot;vertices&quot;].data;

	if( !vertices_a || !vertices_b || vertices_a.length != vertices_b.length )
		return 0;

	var diff = 0;
	for( var i = 0; i &lt; vertices_a.length; i+=3 )
		diff += vec3.distance( vertices_a.subarray(i,i+3), vertices_b.subarray(i,i+3) );
	return diff;
}

LS.registerComponent( MorphDeformer );
LS.MorphDeformer = MorphDeformer;

//SHADER BLOCKS ******************************************

MorphDeformer.morph_streams_enabled_shader_code = &quot;\n\
	\n\
	//max vertex attribs are 16 usually, so 10 are available after using 6 for V,N,UV,UV2,BW,BI\n\
	attribute vec3 a_vertex_morph0;\n\
	attribute vec3 a_normal_morph0;\n\
	attribute vec3 a_vertex_morph1;\n\
	attribute vec3 a_normal_morph1;\n\
	attribute vec3 a_vertex_morph2;\n\
	attribute vec3 a_normal_morph2;\n\
	attribute vec3 a_vertex_morph3;\n\
	attribute vec3 a_normal_morph3;\n\
	\n\
	uniform vec4 u_morph_weights;\n\
	\n\
	void applyMorphing( inout vec4 position, inout vec3 normal )\n\
	{\n\
		vec3 original_vertex = position.xyz;\n\
		vec3 original_normal = normal.xyz;\n\
		\n\
		if(u_morph_weights[0] != 0.0)\n\
		{\n\
			position.xyz += (a_vertex_morph0 - original_vertex) * u_morph_weights[0]; normal.xyz += (a_normal_morph0 - original_normal) * u_morph_weights[0];\n\
		}\n\
		if(u_morph_weights[1] != 0.0)\n\
		{\n\
			position.xyz += (a_vertex_morph1 - original_vertex) * u_morph_weights[1]; normal.xyz += (a_normal_morph1 - original_normal) * u_morph_weights[1];\n\
		}\n\
		if(u_morph_weights[2] != 0.0)\n\
		{\n\
			position.xyz += (a_vertex_morph2 - original_vertex) * u_morph_weights[2]; normal.xyz += (a_normal_morph2 - original_normal) * u_morph_weights[2];\n\
		}\n\
		if(u_morph_weights[3] != 0.0)\n\
		{\n\
			position.xyz += (a_vertex_morph3 - original_vertex) * u_morph_weights[3]; normal.xyz += (a_normal_morph3 - original_normal) * u_morph_weights[3];\n\
		}\n\
	}\n\
&quot;;

MorphDeformer.morph_texture_enabled_shader_code = &quot;\n\
	\n\
	attribute float a_morphing_ids;\n\
	\n\
	uniform sampler2D u_morph_vertices_texture;\n\
	uniform sampler2D u_morph_normals_texture;\n\
	uniform vec4 u_morph_texture_size;\n\
	\n\
	uniform vec4 u_morph_weights;\n\
	\n\
	void applyMorphing( inout vec4 position, inout vec3 normal )\n\
	{\n\
		vec2 coord;\n\
		coord.x = ( mod( a_morphing_ids, u_morph_texture_size.x ) + 0.5 ) / u_morph_texture_size.x;\n\
		coord.y = 1.0 - ( floor( a_morphing_ids / u_morph_texture_size.x ) + 0.5 ) / u_morph_texture_size.y;\n\
		position.xyz += texture2D( u_morph_vertices_texture, coord ).xyz;\n\
		normal.xyz += texture2D( u_morph_normals_texture, coord ).xyz;\n\
	}\n\
&quot;;

MorphDeformer.morph_enabled_shader_code = &quot;\n\
	\n\
	#pragma shaderblock morphing_mode\n\
&quot;;


MorphDeformer.morph_disabled_shader_code = &quot;\nvoid applyMorphing( inout vec4 position, inout vec3 normal ) {}\n&quot;;

// ShaderBlocks used to inject to shader in runtime
var morphing_block = new LS.ShaderBlock(&quot;morphing&quot;);
morphing_block.addCode( GL.VERTEX_SHADER, MorphDeformer.morph_enabled_shader_code, MorphDeformer.morph_disabled_shader_code );
morphing_block.register();
MorphDeformer.shader_block = morphing_block;

var morphing_streams_block = new LS.ShaderBlock(&quot;morphing_streams&quot;);
morphing_streams_block.defineContextMacros( { &quot;morphing_mode&quot;: &quot;morphing_streams&quot;} );
morphing_streams_block.addCode( GL.VERTEX_SHADER, MorphDeformer.morph_streams_enabled_shader_code, MorphDeformer.morph_disabled_shader_code );
morphing_streams_block.register();
MorphDeformer.morphing_streams_block = morphing_streams_block;

var morphing_texture_block = new LS.ShaderBlock(&quot;morphing_texture&quot;);
morphing_texture_block.defineContextMacros( { &quot;morphing_mode&quot;: &quot;morphing_texture&quot;} );
morphing_texture_block.addCode( GL.VERTEX_SHADER, MorphDeformer.morph_texture_enabled_shader_code, MorphDeformer.morph_disabled_shader_code );
morphing_texture_block.register();
MorphDeformer.morphing_texture_block = morphing_texture_block;
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
